// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

//! RSA, a public-key encryption algorithm.

use crate::crypto::sig;

#[cfg(doc)]
use sig::{Sign, Verify};

/// A length for the modulus of an RSA public key.
#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]
pub enum ModulusLength {
    /// A 2048-bit modulus.
    Bits2048,
    /// A 3072-bit modulus.
    Bits3072,
    /// A 4096-bit modulus.
    Bits4096,
}

impl ModulusLength {
    /// Returns the number of bytes necessary to represent a modulus (or,
    /// equivalently, a ciphertext) of this size.
    pub fn byte_len(self) -> usize {
        self.bit_len() / 8
    }

    /// Returns the number of bits necessary to represent a modulus of this
    /// size.
    pub fn bit_len(self) -> usize {
        match self {
            Self::Bits2048 => 2048,
            Self::Bits3072 => 3072,
            Self::Bits4096 => 4096,
        }
    }

    /// Returns a `ModulusLength` variant corresponding to the given number of
    /// bytes, if one exists.
    pub fn from_byte_len(len: usize) -> Option<Self> {
        Self::from_bit_len(len * 8)
    }

    /// Returns a `ModulusLength` variant corresponding to the given number of
    /// bits, if one exists.
    pub fn from_bit_len(len: usize) -> Option<Self> {
        match len {
            2048 => Some(Self::Bits2048),
            3072 => Some(Self::Bits3072),
            4096 => Some(Self::Bits4096),
            _ => None,
        }
    }
}

/// The RSA public key type for a particular [`Builder`] type.
///
/// Rather than prescribe specific types of RSA keys, a particular [`Builder`]
/// implementation can provide its own key types, which implement this
/// trait.
pub trait PublicKey {
    /// Returns this key's modulus length.
    fn len(&self) -> ModulusLength;

    /// Returns true is this key is empty
    fn is_empty(&self) -> bool {
        false
    }
}

/// The RSA public/private keypair type for a particular [`Builder`]
/// type.
///
/// This type is the keypair analogue of [`PublicKey`].
pub trait KeyPair {
    /// The corresponding [`PublicKey`] implementation for this `KeyPair`.
    type Pub: PublicKey;

    /// Returns a copy of the public component of this `KeyPair`.
    fn public(&self) -> Self::Pub;

    /// Returns the public key's modulus length.
    fn pub_len(&self) -> ModulusLength;
}

/// PKCS#1.5-encoded RSA signatures using SHA-256 for hashing.
pub struct RsaPkcs1Sha256 {}

/// A builder for constructing primed RSA engines.
///
/// In particular, a value of a type implementing this trait already has
/// everything it needs (such as OS handles) to start performing RSA
/// operations.
///
/// The `Algo` parameter is provided for re-using this trait with different
/// RSA-based schemes, such as `RsaPkcs1Sha256`. The key type will be specific
/// to each scheme.
pub trait Builder<Algo> {
    /// The concrete `Verify` generated by this trait.
    type Verify: sig::VerifyFor<Algo>;
    /// The concrete `Sign` generated by this trait.
    type Sign: sig::SignFor<Algo>;

    /// The key type used to create verifiers.
    type Key;
    /// The public/private keypair used to create signers.
    type KeyPair;

    /// Checks whether [`Self::Verify`] supports public keys with moduli of
    /// length `len`. This function is primarily for `manticore` to dynamically
    /// discover all the capabilities of an engine.
    fn supports_modulus(&self, len: ModulusLength) -> bool;

    /// Creates a new [`Verify`], primed with the given key, which may be used
    /// repeatedly to perform operations.
    fn new_verifier(
        &self,
        key: Self::Key,
    ) -> Result<Self::Verify, sig::VerifyError<Self::Verify>>;

    /// Creates a new [`Sign`], primed with the given keypair, which may be
    /// used repeatedly to perform operations.
    fn new_signer(
        &self,
        keypair: Self::KeyPair,
    ) -> Result<Self::Sign, sig::SignError<Self::Sign>>;
}
